<html>

<head>
	<title>Starting Code for 1st Project 2017 - with lights and textures</title>
	<style>
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}

		canvas {
			width: 100%;
			height: 100%;
		}
	</style>
</head>

<body>

	<script type="module">

		import * as THREE from './lib/three.module.js';

		import Stats from './lib/stats.module.js';

		import { OrbitControls } from './lib/OrbitControls.js';
		import { FirstPersonControls } from './lib/FirstPersonControls.js';
		import { BufferGeometryUtils } from './lib/BufferGeometryUtils.js';
		import { Water } from './lib/Water.js';

		function getHeightData(img, scale) {

			scale = scale || 1;

			var canvas = document.createElement('canvas');
			canvas.width = img.width;
			canvas.height = img.height;
			var context = canvas.getContext('2d');

			var size = img.width * img.height;
			console.log(size);

			context.drawImage(img, 0, 0);

			var imgd = context.getImageData(0, 0, img.width, img.height);
			var pix = imgd.data;
			var data = [];

			for (var row = 0; row < img.height; row++) {
				data.push([]);
				for (var col = 0; col < img.width; col++) {
					var offset = row * img.width * 4 + col * 4;
					var r = pix[offset];
					var g = pix[offset + 1];
					var b = pix[offset + 2];
					var a = pix[offset + 3];

					data[row].push({
						value: scale * (r + g + b) / 3,
						alpha: a
					});
				}
			}

			return data;
		}

		function createTerrainPlanes() {

			var createPlanes = function () {
				var pxGeometry = new THREE.PlaneBufferGeometry(1, 1);
				pxGeometry.rotateY(Math.PI / 2);
				pxGeometry.translate(0.5, 0, 0);
				var nxGeometry = new THREE.PlaneBufferGeometry(1, 1);
				nxGeometry.rotateY(-Math.PI / 2);
				nxGeometry.translate(-0.5, 0, 0);
				var pyGeometry = new THREE.PlaneBufferGeometry(1, 1);
				pyGeometry.rotateX(- Math.PI / 2);
				pyGeometry.translate(0, 0.5, 0);
				var nyGeometry = new THREE.PlaneBufferGeometry(1, 1);
				nyGeometry.rotateX(Math.PI / 2);
				nyGeometry.translate(0, -0.5, 0);
				var pzGeometry = new THREE.PlaneBufferGeometry(1, 1);
				pzGeometry.translate(0, 0, 0.5);
				var nzGeometry = new THREE.PlaneBufferGeometry(1, 1);
				nzGeometry.rotateY(Math.PI);
				nzGeometry.translate(0, 0, -0.5);

				return [pxGeometry, nxGeometry, pyGeometry, nyGeometry, pzGeometry, nzGeometry];
			}

			var result = {};

			// Dirt
			{
				var planes = createPlanes();

				for (var i = 0; i < planes.length; i++) {
					planes[i].attributes.uv.array[0] = 0.00;
					planes[i].attributes.uv.array[1] = 1.00;
					planes[i].attributes.uv.array[2] = 0.25;
					planes[i].attributes.uv.array[3] = 1.00;
					planes[i].attributes.uv.array[4] = 0.00;
					planes[i].attributes.uv.array[5] = 0.75;
					planes[i].attributes.uv.array[6] = 0.25;
					planes[i].attributes.uv.array[7] = 0.75;
				}

				result.dirt = planes;
			}

			// Dirt with grass
			{
				var planes = createPlanes();

				for (var i = 0; i < planes.length; i++) {
					planes[i].attributes.uv.array[0] = 0.50;
					planes[i].attributes.uv.array[1] = 1.00;
					planes[i].attributes.uv.array[2] = 0.75;
					planes[i].attributes.uv.array[3] = 1.00;
					planes[i].attributes.uv.array[4] = 0.50;
					planes[i].attributes.uv.array[5] = 0.75;
					planes[i].attributes.uv.array[6] = 0.75;
					planes[i].attributes.uv.array[7] = 0.75;
				}

				planes[2].attributes.uv.array[0] = 0.25;
				planes[2].attributes.uv.array[1] = 1.00;
				planes[2].attributes.uv.array[2] = 0.50;
				planes[2].attributes.uv.array[3] = 1.00;
				planes[2].attributes.uv.array[4] = 0.25;
				planes[2].attributes.uv.array[5] = 0.75;
				planes[2].attributes.uv.array[6] = 0.50;
				planes[2].attributes.uv.array[7] = 0.75;

				result.dirtGrass = planes;
			}

			return result;
		}

		function loadTerrain(scene) {
			var img = new Image();
			// img.src = "textures/heightmap.png";
			img.src = "textures/heightmap_256.png";
			img.onload = function () {
				var data = getHeightData(img, 1);

				var texture_complete_basecolor = new THREE.TextureLoader().load('textures/complete_basecolor.jpg');
				var texture_complete_normal = new THREE.TextureLoader().load('textures/complete_normal.jpg');
				var material = new THREE.MeshPhongMaterial({
					map: texture_complete_basecolor,
					normalMap: texture_complete_normal
				});

				var terrainPlains = createTerrainPlanes();
				var offsetDivider = 2;

				var terrainGeometries = [];
				var riverGeometries = [];
				var matrix = new THREE.Matrix4();

				var xOffset = data.length / offsetDivider;

				var addCube = function (x, y, z, material) {
					matrix.makeTranslation(x, y, z);
					terrainGeometries.push(terrainPlains[material][0].clone().applyMatrix(matrix));
					terrainGeometries.push(terrainPlains[material][1].clone().applyMatrix(matrix));
					terrainGeometries.push(terrainPlains[material][2].clone().applyMatrix(matrix));
					terrainGeometries.push(terrainPlains[material][3].clone().applyMatrix(matrix));
					terrainGeometries.push(terrainPlains[material][4].clone().applyMatrix(matrix));
					terrainGeometries.push(terrainPlains[material][5].clone().applyMatrix(matrix));
				}

				var addRiverPlane = function (x, z) {
					var plane = new THREE.PlaneBufferGeometry(1, 1);
					plane.translate(x, -z, 0);
					riverGeometries.push(plane);
				}

				var addMissingCubes = function (targetHeight, offset, x, z) {
					if (offset > 0) {
						while (offset-- > 1) {
							addCube(x - xOffset, targetHeight + offset - 128, z - zOffset, "dirt");
						}
					}
					else {
						while (offset++ < -1) {
							addCube(x - xOffset, targetHeight + offset - 128, z - zOffset, "dirt");
						}
					}
				}

				for (var row = 0; row < data.length; row++) {
					var dataRow = data[row];
					var zOffset = dataRow.length / offsetDivider;

					for (var col = 0; col < dataRow.length; col++) {
						var heightInfo = dataRow[col];
						var height = heightInfo.value;
						var actualHeight = height - 128;

						addCube(row - xOffset, actualHeight, col - zOffset, actualHeight < 0 ? "dirt" : "dirtGrass");

						if(actualHeight < 0) {
							addRiverPlane(row - xOffset, col - zOffset);
						}

						var nextRow = row + 1;
						var prevRow = row - 1;
						var nextCol = col + 1;
						var prevCol = col - 1;

						var nextRowHeight = nextRow < data.length ? data[nextRow][col].value : height;
						var prevRowHeight = prevRow >= 0 ? data[prevRow][col].value : height;
						var nextColHeight = nextCol < dataRow.length ? data[row][nextCol].value : height;
						var prevColHeight = prevCol >= 0 ? data[row][prevCol].value : height;

						var nextRowHeightDiff = nextRowHeight - height;
						var prevRowHeightDiff = prevRowHeight - height;
						var nextColHeightDiff = nextColHeight - height;
						var prevColHeightDiff = prevColHeight - height;

						if (nextRowHeightDiff < -1) {
							addMissingCubes(height, nextRowHeightDiff, row, col);
						}
						else if (nextRowHeightDiff > 1) {
							addMissingCubes(height, nextRowHeightDiff, nextRow, col);
						}

						if (nextColHeightDiff < -1) {
							addMissingCubes(height, nextColHeightDiff, row, col);
						}
						else if (nextColHeightDiff > 1) {
							addMissingCubes(height, nextColHeightDiff, row, nextCol);
						}
					}
				}

				var terrainGeometry = BufferGeometryUtils.mergeBufferGeometries(terrainGeometries);
				terrainGeometry.computeBoundingSphere();

				var terraingMesh = new THREE.Mesh(terrainGeometry, material);
				terraingMesh.receiveShadow = true;
				scene.add(terraingMesh);

				var riverGeometry = BufferGeometryUtils.mergeBufferGeometries(riverGeometries);
				riverGeometry.computeBoundingSphere();
				var river = new Water(riverGeometry, {
					color: 0xAADCFF,
					scale: 1,
					flowDirection: new THREE.Vector2(1, 0),
					textureWidth: 1024,
					textureHeight: 1024
				});

				river.position.y = 0.3;
				river.rotation.x = Math.PI * - 0.5;
				scene.add(river);
			}
		}

		var scene, camera, renderer, controls, stats;

		function Start() {
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setClearColor(0xf0f0f0);
			renderer.setPixelRatio(window.devicePixelRatio);
			// renderer.gammaInput = true;
			renderer.outputEncoding = THREE.LinearEncoding;
			renderer.shadowMap.enabled = true;
			document.body.appendChild(renderer.domElement);

			camera.position.set(10, 10, 10);
			camera.lookAt(new THREE.Vector3(0, 0, 0));

			// var geometry = new THREE.BoxGeometry(1, 1, 1);
			// var texture = new THREE.TextureLoader().load('textures/11635.jpg');
			// var material = new THREE.MeshPhongMaterial({ map: texture });
			// var cube = new THREE.Mesh(geometry, material);
			// cube.castShadow = true;
			// cube.receiveShadow = true;

			// scene.add(cube);

			let hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);
			hemiLight.color.setHSL(0.6, 1, 0.6);
			hemiLight.groundColor.setHSL(0.095, 1, 0.75);
			hemiLight.position.set(0, 50, 0);
			scene.add(hemiLight);

			let dirLight = new THREE.DirectionalLight(0xffffff, 1);
			dirLight.color.setHSL(0.1, 1, 0.95);
			dirLight.position.set(-1, 1.75, 1);
			dirLight.position.multiplyScalar(50);
			scene.add(dirLight);
			dirLight.castShadow = true;
			dirLight.shadow.mapSize.width = 1024;
			dirLight.shadow.mapSize.height = 1024;

			// // GROUND
			// var groundGeo = new THREE.PlaneBufferGeometry(10000, 10000);
			// var groundMat = new THREE.MeshPhongMaterial({ color: 0xffffff, specular: 0x050505 });
			// groundMat.color.setHSL(0.095, 1, 0.75);
			// var ground = new THREE.Mesh(groundGeo, groundMat);
			// ground.position.y = -0.5;
			// ground.rotation.x = -Math.PI / 2;
			// scene.add(ground);
			// ground.receiveShadow = true;

			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			document.body.appendChild(stats.domElement);

			// // uncomment if you need to draw coordinate axes when building the scene
			// Coordinates.drawAllAxes();

			controls = new OrbitControls(camera, renderer.domElement);
			// controls = new FirstPersonControls(camera, renderer.domElement);
			// controls.movementSpeed = 1;
			// controls.lookSpeed = 0.125;
			// controls.lookVertical = true;
			// controls.movementSpeed = 1;
			// controls.rollSpeed = 0.01;
			// controls.autoForward = false;
			// controls.dragToLook = true;

			loadTerrain(scene);
		}

		function Update() {
			requestAnimationFrame(Update);
			controls.update();
			stats.update();
			Render();
		}

		function Render() {

			renderer.render(scene, camera);
		}

		Start();
		Update();

	</script>
</body>

</html>