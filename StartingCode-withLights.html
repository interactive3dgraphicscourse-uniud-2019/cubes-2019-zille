<html>

<head>
	<title>Starting Code for 1st Project 2017 - with lights and textures</title>
	<style>
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}

		canvas {
			width: 100%;
			height: 100%;
		}
	</style>
</head>

<body>

	<script type="module">

		import * as THREE from './lib/three.module.js';

		import Stats from './lib/stats.module.js';

		import { OrbitControls } from './lib/OrbitControls.js';
		import { FirstPersonControls } from './lib/FirstPersonControls.js';
		import { BufferGeometryUtils } from './lib/BufferGeometryUtils.js';
		import { Water } from './lib/Water.js';

		function getHeightData(img, scale) {

			scale = scale || 1;

			var canvas = document.createElement('canvas');
			canvas.width = img.width;
			canvas.height = img.height;
			var context = canvas.getContext('2d');

			var size = img.width * img.height;
			console.log(size);

			context.drawImage(img, 0, 0);

			var imgd = context.getImageData(0, 0, img.width, img.height);
			var pix = imgd.data;
			var data = [];

			for (var row = 0; row < img.height; row++) {
				data.push([]);
				for (var col = 0; col < img.width; col++) {
					var offset = row * img.width * 4 + col * 4;
					var r = pix[offset];
					var g = pix[offset + 1];
					var b = pix[offset + 2];
					var a = pix[offset + 3];

					data[row].push({
						value: scale * (r + g + b) / 3,
						alpha: a
					});
				}
			}

			return data;
		}

		function createBoxPlanes() {

			var createPlanes = function () {
				var pxGeometry = new THREE.PlaneBufferGeometry(1, 1);
				pxGeometry.rotateY(Math.PI / 2);
				pxGeometry.translate(0.5, 0, 0);
				var nxGeometry = new THREE.PlaneBufferGeometry(1, 1);
				nxGeometry.rotateY(-Math.PI / 2);
				nxGeometry.translate(-0.5, 0, 0);
				var pyGeometry = new THREE.PlaneBufferGeometry(1, 1);
				pyGeometry.rotateX(- Math.PI / 2);
				pyGeometry.translate(0, 0.5, 0);
				var nyGeometry = new THREE.PlaneBufferGeometry(1, 1);
				nyGeometry.rotateX(Math.PI / 2);
				nyGeometry.translate(0, -0.5, 0);
				var pzGeometry = new THREE.PlaneBufferGeometry(1, 1);
				pzGeometry.translate(0, 0, 0.5);
				var nzGeometry = new THREE.PlaneBufferGeometry(1, 1);
				nzGeometry.rotateY(Math.PI);
				nzGeometry.translate(0, 0, -0.5);

				return [pxGeometry, nxGeometry, pyGeometry, nyGeometry, pzGeometry, nzGeometry];
			}

			var result = {};

			// Dirt
			{
				var planes = createPlanes();

				for (var i = 0; i < planes.length; i++) {
					planes[i].attributes.uv.array[0] = 0.00;
					planes[i].attributes.uv.array[1] = 1.00;
					planes[i].attributes.uv.array[2] = 0.25;
					planes[i].attributes.uv.array[3] = 1.00;
					planes[i].attributes.uv.array[4] = 0.00;
					planes[i].attributes.uv.array[5] = 0.75;
					planes[i].attributes.uv.array[6] = 0.25;
					planes[i].attributes.uv.array[7] = 0.75;
				}

				result.dirt = planes;
			}

			// Dirt with grass
			{
				var planes = createPlanes();

				for (var i = 0; i < planes.length; i++) {

					// Skip positive and negative Y
					if (i == 2 || i == 3) {
						continue;
					}
					planes[i].attributes.uv.array[0] = 0.50;
					planes[i].attributes.uv.array[1] = 1.00;
					planes[i].attributes.uv.array[2] = 0.75;
					planes[i].attributes.uv.array[3] = 1.00;
					planes[i].attributes.uv.array[4] = 0.50;
					planes[i].attributes.uv.array[5] = 0.75;
					planes[i].attributes.uv.array[6] = 0.75;
					planes[i].attributes.uv.array[7] = 0.75;
				}

				planes[2].attributes.uv.array[0] = 0.25;
				planes[2].attributes.uv.array[1] = 1.00;
				planes[2].attributes.uv.array[2] = 0.50;
				planes[2].attributes.uv.array[3] = 1.00;
				planes[2].attributes.uv.array[4] = 0.25;
				planes[2].attributes.uv.array[5] = 0.75;
				planes[2].attributes.uv.array[6] = 0.50;
				planes[2].attributes.uv.array[7] = 0.75;

				planes[3].attributes.uv.array[0] = 0.00;
				planes[3].attributes.uv.array[1] = 1.00;
				planes[3].attributes.uv.array[2] = 0.25;
				planes[3].attributes.uv.array[3] = 1.00;
				planes[3].attributes.uv.array[4] = 0.00;
				planes[3].attributes.uv.array[5] = 0.75;
				planes[3].attributes.uv.array[6] = 0.25;
				planes[3].attributes.uv.array[7] = 0.75;

				result.dirtGrass = planes;
			}

			// Plaster
			{
				var planes = createPlanes();

				for (var i = 0; i < planes.length; i++) {
					planes[i].attributes.uv.array[0] = 0.75;
					planes[i].attributes.uv.array[1] = 1.00;
					planes[i].attributes.uv.array[2] = 1.00;
					planes[i].attributes.uv.array[3] = 1.00;
					planes[i].attributes.uv.array[4] = 0.75;
					planes[i].attributes.uv.array[5] = 0.75;
					planes[i].attributes.uv.array[6] = 1.00;
					planes[i].attributes.uv.array[7] = 0.75;
				}

				result.plaster = planes;
			}

			return result;
		}

		function addBoxGeometry(geometries, planes, material, matrix) {
			geometries.push(planes[material][0].clone().applyMatrix(matrix));
			geometries.push(planes[material][1].clone().applyMatrix(matrix));
			geometries.push(planes[material][2].clone().applyMatrix(matrix));
			geometries.push(planes[material][3].clone().applyMatrix(matrix));
			geometries.push(planes[material][4].clone().applyMatrix(matrix));
			geometries.push(planes[material][5].clone().applyMatrix(matrix));
		}

		function ceateBox(planes, planesMaterialName, material) {
			var geometries = [];
			geometries.push(planes[planesMaterialName][0].clone());
			geometries.push(planes[planesMaterialName][1].clone());
			geometries.push(planes[planesMaterialName][2].clone());
			geometries.push(planes[planesMaterialName][3].clone());
			geometries.push(planes[planesMaterialName][4].clone());
			geometries.push(planes[planesMaterialName][5].clone());
			
			var boxGeometry = BufferGeometryUtils.mergeBufferGeometries(geometries);
			boxGeometry.computeBoundingSphere();

			var boxMesh = new THREE.Mesh(boxGeometry, material);
			boxMesh.receiveShadow = true;
			boxMesh.castShadow = true;
			return boxMesh;
		}

		function loadTerrain(scene, planes, material) {
			var img = new Image();
			img.src = "textures/heightmap_collina.png";
			img.onload = function () {
				var data = getHeightData(img, 1);

				var offsetDivider = 2;

				var terrainGeometries = [];
				var riverGeometries = [];
				var matrix = new THREE.Matrix4();

				var xOffset = data.length / offsetDivider;

				var addCube = function (x, y, z, material) {
					matrix.makeTranslation(x, y, z);
					addBoxGeometry(terrainGeometries, planes, material, matrix);
				}

				var addRiverPlane = function (x, z) {
					var plane = new THREE.PlaneBufferGeometry(1, 1);
					plane.translate(x, -z, 0);
					riverGeometries.push(plane);
				}

				var addMissingCubes = function (targetHeight, offset, x, z) {
					if (offset > 0) {
						while (offset-- > 1) {
							addCube(x - xOffset, targetHeight + offset - 128, z - zOffset, "dirt");
						}
					}
					else {
						while (offset++ < -1) {
							addCube(x - xOffset, targetHeight + offset - 128, z - zOffset, "dirt");
						}
					}
				}

				for (var row = 0; row < data.length; row++) {
					var dataRow = data[row];
					var zOffset = dataRow.length / offsetDivider;

					for (var col = dataRow.length - 1; col >= 0; col--) {
						var heightInfo = dataRow[col];
						var height = heightInfo.value;
						var actualHeight = height - 128;

						addCube(col - zOffset, actualHeight, row - zOffset, actualHeight < 0 ? "dirt" : "dirtGrass");

						if (actualHeight < 0) {
							addRiverPlane(col - xOffset, row - zOffset);
						}

						var nextRow = row + 1;
						var prevRow = row - 1;
						var nextCol = col + 1;
						var prevCol = col - 1;

						var nextRowHeight = nextRow < data.length ? data[nextRow][col].value : height;
						var prevRowHeight = prevRow >= 0 ? data[prevRow][col].value : height;
						var nextColHeight = nextCol < dataRow.length ? data[row][nextCol].value : height;
						var prevColHeight = prevCol >= 0 ? data[row][prevCol].value : height;

						var nextRowHeightDiff = nextRowHeight - height;
						var prevRowHeightDiff = prevRowHeight - height;
						var nextColHeightDiff = nextColHeight - height;
						var prevColHeightDiff = prevColHeight - height;

						if (nextRowHeightDiff < -1) {
							addMissingCubes(height, nextRowHeightDiff, col, row);
						}
						else if (nextRowHeightDiff > 1) {
							addMissingCubes(height, nextRowHeightDiff, col, nextRow);
						}

						if (nextColHeightDiff < -1) {
							addMissingCubes(height, nextColHeightDiff, col, row);
						}
						else if (nextColHeightDiff > 1) {
							addMissingCubes(height, nextColHeightDiff, nextCol, row);
						}
					}
				}

				var terrainGeometry = BufferGeometryUtils.mergeBufferGeometries(terrainGeometries);
				terrainGeometry.computeBoundingSphere();

				var terrainMesh = new THREE.Mesh(terrainGeometry, material);
				terrainMesh.receiveShadow = true;
				scene.add(terrainMesh);

				var riverGeometry = BufferGeometryUtils.mergeBufferGeometries(riverGeometries);
				riverGeometry.computeBoundingSphere();
				var river = new Water(riverGeometry, {
					color: 0xAADCFF,
					scale: 1,
					flowDirection: new THREE.Vector2(1, 0),
					textureWidth: 1024,
					textureHeight: 1024
				});

				river.position.y = 0.3;
				river.rotation.x = Math.PI * - 0.5;
				scene.add(river);
			}
		}

		function createWall(width, height, hasDoor, planes, material) {
			var wallGeometries = [];
			var matrix = new THREE.Matrix4();
			var doorPosition = hasDoor ? Math.floor(width / 2) : -1;

			for (var w = 0; w < width; w++) {
				for (var h = 0; h < height; h++) {

					if (w == doorPosition && h < 2) {
						continue;
					}

					matrix.makeTranslation(w, h, 0);
					addBoxGeometry(wallGeometries, planes, "plaster", matrix);
				}
			}

			var wallGeometry = BufferGeometryUtils.mergeBufferGeometries(wallGeometries);
			wallGeometry.computeBoundingSphere();

			var wallMesh = new THREE.Mesh(wallGeometry, material);
			wallMesh.receiveShadow = true;
			wallMesh.castShadow = true;
			return wallMesh;
		}

		function createHouse(x, z, width, height, depth, planes, material) {
			var frontWall = createWall(width, height - 1, true, planes, material);
			frontWall.position.z = depth - 1;

			var backWall = createWall(width, height - 1, false, planes, material);

			var leftWall = createWall(depth - 2, height - 1, false, planes, material);
			leftWall.position.z = 1;
			leftWall.rotation.y = -90 * Math.PI / 180;

			var rightWall = createWall(depth - 2, height - 1, false, planes, material);
			rightWall.position.x = width - 1;
			rightWall.position.z = 1;
			rightWall.rotation.y = -90 * Math.PI / 180;

			var roof = createWall(width, depth, false, planes, material);
			roof.position.y = height - 1;
			roof.rotation.x = 90 * Math.PI / 180;

			var house = new THREE.Object3D();
			house.add(frontWall);
			house.add(backWall);
			house.add(leftWall);
			house.add(rightWall);
			house.add(roof);
			house.position.x = x;
			house.position.y = 1;
			house.position.z = z;

			return house;
		}

		function createHouses(scene, planes, material) {
			scene.add(createHouse(10, 10, 7, 3, 5, planes, material));
		}

		var scene, camera, renderer, controls, stats, clock, person;

		function Start() {
			clock = new THREE.Clock();
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setClearColor(0xf0f0f0);
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.outputEncoding = THREE.LinearEncoding;
			renderer.shadowMap.enabled = true;
			document.body.appendChild(renderer.domElement);

			camera.position.set(0, 10, 10);
			camera.lookAt(new THREE.Vector3(0, 0, 0));

			let hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);
			hemiLight.color.setHSL(0.6, 1, 0.6);
			hemiLight.groundColor.setHSL(0.095, 1, 0.75);
			hemiLight.position.set(0, 50, 0);
			scene.add(hemiLight);

			let dirLight = new THREE.DirectionalLight(0xffffff, 1);
			dirLight.color.setHSL(0.1, 1, 0.95);
			dirLight.position.set(-1, 1.75, 1);
			dirLight.position.multiplyScalar(50);
			scene.add(dirLight);
			dirLight.castShadow = true;
			dirLight.shadow.mapSize.width = 1024;
			dirLight.shadow.mapSize.height = 1024;

			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			document.body.appendChild(stats.domElement);

			controls = new OrbitControls(camera, renderer.domElement);
			// controls = new FirstPersonControls(camera, renderer.domElement);
			// // controls.movementSpeed = 1;
			// // controls.lookSpeed = 0.125;
			// // controls.lookVertical = true;
			// controls.movementSpeed = 1;
			// controls.rollSpeed = 0.01;
			// controls.autoForward = false;
			// controls.dragToLook = false;

			var texture_complete_basecolor = new THREE.TextureLoader().load('textures/complete_basecolor.jpg');
			var texture_complete_normal = new THREE.TextureLoader().load('textures/complete_normal.jpg');
			var texture_complete_roughness = new THREE.TextureLoader().load('textures/complete_roughness.jpg')
			var material = new THREE.MeshStandardMaterial({
				map: texture_complete_basecolor,
				normalMap: texture_complete_normal,
				roughnessMap: texture_complete_roughness
			});
			var boxPlanes = createBoxPlanes();

			loadTerrain(scene, boxPlanes, material);
			createHouses(scene, boxPlanes, material);

			person = ceateBox(boxPlanes, "plaster", material);
			scene.add(person);
		}

		var personPosition = 0;
		var speed = 0.01;
		function Update() {
			requestAnimationFrame(Update);
			// controls.update(clock.getDelta());
			controls.update();
			stats.update();

			person.position.y = 1 + Math.abs(Math.sin(personPosition + (speed * Math.PI * clock.getDelta())));

			Render();
		}

		function Render() {

			renderer.render(scene, camera);
		}

		Start();
		Update();

	</script>
</body>

</html>